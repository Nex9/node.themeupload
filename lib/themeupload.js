// Generated by CoffeeScript 1.6.3
(function() {
  var YAML, args, fs, hash, mime, path, restler, upload, walk,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require("fs");

  restler = require("restler");

  walk = require("walkdir");

  YAML = require("libyaml");

  mime = require("mime");

  hash = require("mhash").hash;

  upload = function(inpath) {
    var callcounter, cleanup, domain, exclude, flushCache, gaeVersion, getDomain, getNextVersion, opts, parseYaml, pathFilter, totalfiles, uploadFile, version, walkFiles;
    opts = {};
    exclude = ['theme.yaml', 'index.html'];
    domain = '';
    version = null;
    totalfiles = 0;
    callcounter = 0;
    gaeVersion = function() {
      if (opts.gaeversion === 'default') {
        return '';
      }
      return '.' + opts.gaeversion;
    };
    getDomain = function() {
      domain = 'http://' + opts.tenant + gaeVersion() + '.nex9-99.appspot.com';
      if (opts.debug) {
        return domain = 'http://localhost:8080';
      }
    };
    parseYaml = function() {
      var yamlPath;
      yamlPath = inpath + '/theme.yaml';
      if (!fs.existsSync(yamlPath)) {
        process.kill();
      }
      return opts = YAML.readFileSync(yamlPath)[0];
    };
    getNextVersion = function() {
      var getNextDone, url;
      getNextDone = function(data) {
        version = parseInt(data);
        console.log('themeversion is', version);
        return walkFiles();
      };
      url = domain + '/api/v2/themeupload/next';
      return restler.get(url).on('complete', getNextDone);
    };
    pathFilter = function(path) {
      var fname;
      fname = path.split('/')[path.split('/').length - 1];
      if (__indexOf.call(exclude, fname) >= 0) {
        return false;
      }
      if (fname.indexOf('.') === 0) {
        return false;
      }
      return true;
    };
    walkFiles = function() {
      var filepath, i, paths, _i, _len, _results;
      paths = walk.sync(inpath);
      paths = paths.filter(pathFilter);
      totalfiles = paths.length;
      callcounter = totalfiles;
      console.log('starting deployment for', paths.length, 'paths');
      _results = [];
      for (i = _i = 0, _len = paths.length; _i < _len; i = ++_i) {
        filepath = paths[i];
        _results.push(uploadFile(filepath, i));
      }
      return _results;
    };
    flushCache = function() {
      var data, url;
      console.log('flushing the cache');
      data = {
        data: {
          key: 'UWSMJGaPRcAmgXbNjOhHYrT2VzIkufKqy9eptsExCQnFD'
        }
      };
      url = domain + '/api/flushcache';
      return restler.post(url, data).on('complete', function(data, response) {
        return console.log('deployment done!');
      });
    };
    cleanup = function() {
      var url;
      console.log('done uploading files...');
      if (opts.setdefault) {
        console.log('going to set the default version to', version);
        url = domain + '/api/v2/themeupload/setdefault/' + version;
        return restler.get(url).on('complete', flushCache);
      } else {
        return flushCache();
      }
    };
    uploadFile = function(filepath, i) {
      var filedata, mimetype, postData, serving_path, uploadBinary;
      uploadBinary = function(body) {
        var data, stats;
        stats = fs.statSync(filepath);
        data = {
          multipart: true,
          data: {
            file: restler.file(filepath, null, stats.size, null, mimetype)
          }
        };
        return restler.post(body, data).on('complete', function(data, response) {
          console.log('done uploading', serving_path);
          callcounter -= 1;
          if (callcounter === 0) {
            return cleanup();
          }
        });
      };
      postData = function(filedata) {
        var payload, url;
        url = domain + '/api/v2/themeupload/uploadurl';
        payload = JSON.stringify(filedata);
        return restler.post(url, {
          data: payload
        }).on('complete', uploadBinary);
      };
      serving_path = '/public' + filepath.split('/public')[1];
      mimetype = mime.lookup(serving_path);
      filedata = {
        path: serving_path,
        mimetype: mimetype,
        version: version,
        sha: 0
      };
      return fs.readFile(filepath, function(err, data) {
        filedata.sha = hash('sha224', data);
        return postData(filedata);
      });
    };
    console.log('getting configuration...');
    parseYaml();
    getDomain();
    return getNextVersion();
  };

  args = process.argv;

  if (args.length !== 3) {
    if (args.length === 2) {
      console.log('the command must be called with path as an argument');
      return;
    } else if (args.length > 3) {
      console.log('too many arguments');
      return;
    }
  }

  path = args[args.length - 1];

  if (fs.existsSync(path) && fs.existsSync(path + '/public')) {
    upload(path + '/public');
  } else {
    console.log('fuck');
  }

}).call(this);
