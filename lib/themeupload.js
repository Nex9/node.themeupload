// Generated by CoffeeScript 1.9.1
(function() {
  var ThemeUpload, Upload, YAML, async, fs, md5, mime, pathMod, restler, walk,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require("fs");

  restler = require("restler");

  walk = require("walkdir");

  YAML = require("libyaml");

  mime = require("mime");

  md5 = require("MD5");

  pathMod = require("path");

  async = require("async");

  Upload = (function() {
    function Upload(inpath) {
      this.pathFilter = bind(this.pathFilter, this);
      this.parseYaml = bind(this.parseYaml, this);
      this.inpath = inpath;
      this.opts = {};
      this.exclude = ['theme.yaml', 'index.html'];
      this.domain = '';
      this.version = null;
      this.totalfiles = 0;
      this.callcounter = 0;
      console.log('this inpath', this.inpath);
      this.run();
    }

    Upload.prototype.run = function() {
      console.log('getting configuration...');
      this.parseYaml();
      this.getDomain();
      console.log('domain is', this.domain);
      console.log('opts', this.opts);
      return this.getNextVersion();
    };

    Upload.prototype.getDomain = function() {
      this.domain = 'http://themes-nex9.rhcloud.com';
      if (this.opts.debug) {
        return this.domain = 'http://localhost:8001';
      }
    };

    Upload.prototype.parseYaml = function() {
      var yamlPath;
      yamlPath = this.inpath + '/theme.yaml';
      if (!fs.existsSync(yamlPath)) {
        process.kill();
      }
      return this.opts = YAML.readFileSync(yamlPath)[0];
    };

    Upload.prototype.getNextVersion = function() {
      var url;
      url = this.domain + '/api/nextversion';
      console.log('nextversion url', url);
      return restler.postJson(url, {
        '_tenant': this.opts.tenant
      }).on('complete', (function(_this) {
        return function(data, response) {
          _this.version = parseInt(data);
          console.log('themeversion is', _this.version);
          return _this.walkFiles();
        };
      })(this));
    };

    Upload.prototype.pathFilter = function(path) {
      var fname;
      fname = path.split('/')[path.split('/').length - 1];
      if (fs.lstatSync(path).isDirectory()) {
        return false;
      }
      if (indexOf.call(this.exclude, fname) >= 0) {
        return false;
      }
      if (fname.indexOf('.') === 0) {
        return false;
      }
      return true;
    };

    Upload.prototype.walkFiles = function() {
      var _this, paths;
      paths = walk.sync(this.inpath);
      paths = paths.filter(this.pathFilter);
      _this = this;
      return async.eachLimit(paths, 10, (function(_this) {
        return function(path, cb) {
          var ext, mimetype, stats;
          ext = pathMod.extname(path);
          mimetype = mime.lookup(path);
          return stats = fs.stat(path, function(err, stats) {
            var payload, url;
            payload = {
              'action': 'uploadurl',
              'filename': path.split('/public')[1],
              'mimetype': mimetype,
              'version': _this.version,
              'tenant': _this.opts.tenant
            };
            url = _this.domain + "/api/themefile/upload";
            return restler.postJson(url, payload).on('complete', function(gcsurl, response) {
              var data;
              data = {
                multipart: true,
                data: {
                  file: restler.file(path, null, stats.size, null, mimetype)
                }
              };
              return restler.put(gcsurl, data).on('complete', function(data, response) {
                console.log(pathMod.basename(path), '...done');
                return fs.readFile(path, function(err, buf) {
                  var themefile;
                  themefile = {
                    _tenant: _this.opts.tenant,
                    path: payload.filename,
                    version: _this.version,
                    md5: md5(buf),
                    size: stats.size,
                    mimetype: mimetype,
                    gs_path: _this.opts.tenant + "/" + _this.version + payload.filename
                  };
                  url = _this.domain + "/api/themefile";
                  return restler.postJson(url, themefile).on('complete', function(data, response) {
                    return cb();
                  });
                });
              });
            });
          });
        };
      })(this), (function(_this) {
        return function(err) {
          var data, url;
          console.log('done uploading files...');
          if (_this.opts.setdefault) {
            console.log('going to set the default version to', _this.version);
            url = _this.domain + '/api/setdefault';
            data = {
              version: _this.version,
              _tenant: _this.opts.tenant
            };
            return restler.postJson(url, data).on('complete', function(data, response) {
              return console.log('all done!');
            });
          }
        };
      })(this));
    };

    return Upload;

  })();

  ThemeUpload = (function() {
    function ThemeUpload() {}

    ThemeUpload.prototype.exec = function() {
      var args, path;
      args = process.argv;
      if (args.length !== 3) {
        if (args.length === 2) {
          console.log('the command must be called with path as an argument');
          return;
        } else if (args.length > 3) {
          console.log('too many arguments');
          return;
        }
      }
      path = args[args.length - 1];
      if (fs.existsSync(path) && fs.existsSync(path + '/public')) {
        return new Upload(path + '/public');
      } else {
        return console.log('fuck');
      }
    };

    return ThemeUpload;

  })();

  module.exports = ThemeUpload;

}).call(this);

//# sourceMappingURL=themeupload.js.map
