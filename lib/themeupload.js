// Generated by CoffeeScript 1.6.3
(function() {
  var ThemeUpload, Upload, YAML, fs, hash, mime, restler, walk,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require("fs");

  restler = require("restler");

  walk = require("walkdir");

  YAML = require("libyaml");

  mime = require("mime");

  hash = require("mhash").hash;

  Upload = (function() {
    function Upload(inpath) {
      this.flushCache = __bind(this.flushCache, this);
      this.pathFilter = __bind(this.pathFilter, this);
      this.inpath = inpath;
      this.opts = {};
      this.exclude = ['theme.yaml', 'index.html'];
      this.domain = '';
      this.version = null;
      this.totalfiles = 0;
      this.callcounter = 0;
      console.log('this inpath', this.inpath);
      this.run();
    }

    Upload.prototype.run = function() {
      console.log('getting configuration...');
      this.parseYaml();
      this.getDomain();
      console.log('domain is', this.domain);
      return this.getNextVersion();
    };

    Upload.prototype.gaeVersion = function() {
      if (this.opts.gaeversion === 'default') {
        return '';
      }
      return '.' + this.opts.gaeversion;
    };

    Upload.prototype.getDomain = function() {
      this.domain = 'http://' + this.opts.tenant + this.gaeVersion() + '.nex9-99.appspot.com';
      if (this.opts.debug) {
        return this.domain = 'http://localhost:8080';
      }
    };

    Upload.prototype.parseYaml = function() {
      var yamlPath;
      yamlPath = this.inpath + '/theme.yaml';
      if (!fs.existsSync(yamlPath)) {
        process.kill();
      }
      return this.opts = YAML.readFileSync(yamlPath)[0];
    };

    Upload.prototype.getNextVersion = function() {
      var getNextDone, url,
        _this = this;
      getNextDone = function(data) {
        console.log('data', data);
        _this.version = parseInt(data);
        console.log('themeversion is', _this.version);
        return _this.walkFiles();
      };
      url = this.domain + '/api/v2/themeupload/next';
      return restler.get(url).on('complete', getNextDone);
    };

    Upload.prototype.pathFilter = function(path) {
      var fname;
      fname = path.split('/')[path.split('/').length - 1];
      if (fs.lstatSync(path).isDirectory()) {
        return false;
      }
      if (__indexOf.call(this.exclude, fname) >= 0) {
        return false;
      }
      if (fname.indexOf('.') === 0) {
        return false;
      }
      return true;
    };

    Upload.prototype.walkFiles = function() {
      var filepath, paths, _i, _len, _results;
      paths = walk.sync(this.inpath);
      paths = paths.filter(this.pathFilter);
      this.totalfiles = paths.length;
      this.callcounter = this.totalfiles;
      console.log('starting deployment for', this.totalfiles, 'files');
      _results = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        filepath = paths[_i];
        _results.push(this.uploadFile(filepath));
      }
      return _results;
    };

    Upload.prototype.flushCache = function() {
      var data, url;
      console.log('flushing the cache');
      data = {
        data: {
          key: 'UWSMJGaPRcAmgXbNjOhHYrT2VzIkufKqy9eptsExCQnFD'
        }
      };
      url = this.domain + '/api/flushcache';
      return restler.post(url, data).on('complete', function(data, response) {
        return console.log('deployment done!');
      });
    };

    Upload.prototype.cleanup = function() {
      var url;
      console.log('done uploading files...');
      if (this.opts.setdefault) {
        console.log('going to set the default version to', this.version);
        url = this.domain + '/api/v2/themeupload/setdefault/' + this.version;
        return restler.get(url).on('complete', this.flushCache);
      } else {
        return this.flushCache();
      }
    };

    Upload.prototype.uploadFile = function(filepath) {
      var filedata, mimetype, postData, serving_path, uploadBinary,
        _this = this;
      uploadBinary = function(body) {
        var data, stats;
        stats = fs.statSync(filepath);
        data = {
          multipart: true,
          data: {
            file: restler.file(filepath, null, stats.size, null, mimetype)
          }
        };
        console.log('uploading ->', serving_path);
        return restler.post(body, data).on('complete', function(data, response) {
          _this.callcounter -= 1;
          if (_this.callcounter === 0) {
            return _this.cleanup();
          }
        });
      };
      postData = function(filedata) {
        var payload, url;
        url = _this.domain + '/api/v2/themeupload/uploadurl';
        payload = JSON.stringify(filedata);
        return restler.post(url, {
          data: payload
        }).on('complete', uploadBinary);
      };
      serving_path = filepath.split('/public')[1];
      mimetype = mime.lookup(serving_path);
      filedata = {
        path: serving_path,
        mimetype: mimetype,
        version: this.version,
        sha: 0
      };
      return fs.readFile(filepath, function(err, data) {
        filedata.sha = hash('sha224', data);
        return postData(filedata);
      });
    };

    return Upload;

  })();

  ThemeUpload = (function() {
    function ThemeUpload() {}

    ThemeUpload.prototype.exec = function() {
      var args, path;
      args = process.argv;
      if (args.length !== 3) {
        if (args.length === 2) {
          console.log('the command must be called with path as an argument');
          return;
        } else if (args.length > 3) {
          console.log('too many arguments');
          return;
        }
      }
      path = args[args.length - 1];
      if (fs.existsSync(path) && fs.existsSync(path + '/public')) {
        return new Upload(path + '/public');
      } else {
        return console.log('fuck');
      }
    };

    return ThemeUpload;

  })();

  module.exports = ThemeUpload;

}).call(this);

/*
//@ sourceMappingURL=themeupload.map
*/
